---
title: "Full-Sibling Chinook MCMC"
author: Eric C. Anderson
date: April, 2014
output: 
  html_document:
    toc: true
    highlight: pygments
  pdf_document:
    toc: true
    toc_depth: 3
    highlight: pygments
---

Note that to get this to really be a vignette, I must insert this at the top:
```
<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Building up an MCMC function}
-->
```

```{r}
library(fullsniplings)
library(microbenchmark)
```

## Intro
Having come back to this project after two weeks, I don't quite remember where I was on the bleeding edge of its development.  However, I also figured out a very different way to cast most of what I am trying to do here in terms of factor graphs.  So, this line of development is pretty dead---it will all be supplanted.  Nonetheless, I want to use it to analyze one simple case: nothing but full siblings (no half siblings, even) to see how much a speed advantage this might carry over Colony.  And I want to get this done to present at the coastwide meeting in two weeks.  yikes.

So, I am going to use the chinook full sibling data:
```{r}
dim(fs_dev_test_data$chinook_full_sibs_genos)
```
That is `r nrow(fs_dev_test_data$chinook_full_sibs_genos)` at `r ncol(fs_dev_test_data$chinook_full_sibs_genos)/2` SNPs.

## Moving forward
So, I now think I have gotten my head back around where I need to be.  I have pretty much finished up a function that prepares all th variables for the MCMC.  It is in the file `mcmc1.R` and I can run it like this:
```{r}
chinook_chain <- full_sib_mcmc_initialize(fs_dev_test_data$chinook_full_sibs_genos, mu = 0.005)
```

That has most everything needed to run the MCMC, but there is at least one thing left to be done:
**I have to compute for each individual the individuals that are acceptable, possible full siblings.**  In order to that I will write a function that returns a list with one component for every individual. Yay! I've got that done now with the function `high_logl_pairs` in `fullsniplings.cpp`.  There is also an R version of the function: `find_high_logl_sib_pairs` that takes about 200 times longer.  Holy Crap!  Anyway, it returns a list of vectors, one for each individual.  They are base 0 subscripted. 

Once that is done, then it is time to modify, update, and improve `gibbs_update_one_indiv_in_place` which is found in `fullsniplings.cpp`.  Here are some things that need to be done.

- Make `gibbs_update_one_indiv_in_place` return some information about where the individual started and where he finished up (i.e. whether his sibling group was updated)
- Make another Cpp function that can call `gibbs_update_one_indiv_in_place` multiple times.  Give this new function a vector of indices of individuals (which may appear multiple times) and have it cycle through that whole vector before returning a result.
- Figure out how to compute the (pseudo-Gibbs) prior for each possible sibship. I particularly have to think about how to compute the prior on its being a totally new sibgroup (of just itself) and how that interacts with the "acceptable full siblings".
- Actually update the sibhip of the individual.
- Update it so that it will use only acceptable, possible, full siblings.


## Developing the gibbs update function
Here is a simple thing to do to call the function:
```{r}
cc <- chinook_chain
gibbs_update_one_indiv_in_place(FSL = cc$FSL, IFS = cc$IFS, LMMI = cc$LMMI, LMMFS = cc$LMMFS, PMMFS = cc$PMMFS, KidProngs = cc$KidProngs, Pile = cc$Pile, AFSL = cc$AFSL, Gfreqs = cc$Gfreqs, UPG = cc$UPG, TP = cc$TP, IndLiks = cc$IndLiks, Ind = 0)
```

Here is a scrap that I might want to look at for figuring out how to reinsert stuff at some point.:

    if(n==1) {  // if Ind is the only one in his current sibgroup, then use that sibgroup to see if he 
                // wants to be a solo sib-group still.
      KidProngs( _, fsp) = Gfreqs; 
    }
    else if(n>1) {
    
